---
title: "Assignment-5\n \\vspace{1in}"
output: pdf_document
date: "2023-03-31\n \\vspace{1in}"
author: "Imanbayeva Sofya, Mazzi Lapo, Piras Mattia, Srivastava Dev\n \\vspace{1in}"
subtitle: "Group 22\n \\vspace{1in}"
---

```{r setup, include=FALSE, echo=TRUE}
knitr::opts_chunk$set(echo = FALSE, out.height = "75%", out.width = "75%")
list.of.packages <- c("dlm", "fpp2", "forecast","ggplot2","depmixS4","tidyverse","dplyr","rlang","tseries","zoo")
if(!require(dlm)){
    install.packages("dlm")
    library(dlm)
}
if(!require(fpp2)){
    install.packages("fpp2")
    library(fpp2)
}
if(!require(forecast)){
    install.packages("forecast")
    library(forecast)
}
if(!require(ggplot2)){
    install.packages("ggplot2")
    library(ggplot2)
}
if(!require(depmixS4)){
    install.packages("depmixS4")
    library(depmixS4)
}
if(!require(markovchain)){
    install.packages("markovchain")
    library(markovchain)
}
if(!require(tidyverse)){
    install.packages("tidyverse")
    library(tidyverse)
}
if(!require(dplyr)){
    install.packages("dplyr")
    library(dplyr)
}
if(!require(rlang)){
    install.packages("rlang")
    library(rlang)
}
  if(!require(tseries)){
    install.packages("tseries")
    library(tseries)
  }
  if(!require(zoo)){
    install.packages("zoo")
    library(zoo)
}
```

```{r Nile graph}

plot(Nile, main = "Graph 1: River Nile annual flow in 10^8 cubic meters (1871-1970)", xlab = "Time", ylab= "Water flow in 10^8 cubic meters")
```

Let us consider the following random walk plus noise model to be applied to the Nile data:
\begin{eqnarray*} 
Y_t &= \theta_t + v_t \quad    & v_t \overset{i.i.d.}\sim N(0, V)\\
\theta_t &= \theta_{t-1} + w_t \quad   & v_t \overset{i.i.d.}\sim N(0, W)
\end{eqnarray*}

We will set V = 15100 and W = 1470 and the initial distribution $\theta_0 \sim N(1000,1000)$ for our model

```{r model}
mod <- dlm(m0=1000, C0=1000, FF=1, V=15100, GG=1, W=1470)
NileFilt <- dlmFilter(Nile, mod)
```

Plotting the filtered estimates we get

```{r plot filtered estimates}
plot(dropFirst(NileFilt$m),ylab = "Filtered Estimates", main = "Graph 2: Filtered Estimates")
```

```{r re-estimating}
mod <- dlmModPoly(1,dV=15100, dW=1470)
outFilt<- dlmFilter(Nile,mod)
names(outFilt)
filterEstimates= window(outFilt$m,start=start(Nile)[1])
```

Computing the variance 
```{r variance comput,outwidth=0.9}
n <- length(Nile)
listC <- dlmSvd2var(outFilt$U.C, outFilt$D.C)
sqrtC <- sqrt(unlist(listC))
ts.plot(sqrtC[-1], ylab="standard deviation", main = "Graph 3: Standard deviation of filtering states estimates")
```

As we can see from the graph above, the standard deviations of the filtering state have their maximal values at the beginning of the time series, sharply decreasing as time pass by. This reflects the fact that we have less information about the initial state of the system. As new observations arrive the filtering state estimates become more and more accurate, hence the observation of the decrease in the standard deviations over time. 

We finally plot the whole data along with the filtered estimates with 95% confidence interval

```{r final plot}
par(mar = c(2, 4, 1, 1) + 0.1, cex = 0.6)
plot(Nile, main = "Graph 4: Data and Filtered Estimates with 95% CI", xlab = "Time", ylab= "Water flow in 10^8 cubic meters", type = "o")
lines(dropFirst(NileFilt$m), col = "orange")
lines(dropFirst(NileFilt$m + 1.96*sqrtC), col = "blue", lty = "dotdash")
lines(dropFirst(NileFilt$m - 1.96*sqrtC), col = "blue", lty = "dotdash")
legend("bottomleft", legend = c("data","filtered","CI"),
col = c("black", "orange","blue"),
lty = c("solid", "solid", "dotdash"),
pch = c(16, NA, NA))
```

FORECASTING

```{r compute sd for forecast}
varR <- unlist(dlmSvd2var(NileFilt$U.R,NileFilt$D.R))
sdR <- sqrt(varR)
```


```{r forecasting}
par(mar = c(2, 4, 1, 1) + 0.1, cex = 0.6)
a <- window(cbind(Nile, NileFilt$f),
start = 1871, end = 1970)
plot(a[, 1], type = 'o', col = "black",
xlab = "", ylab = "Level",main = "Graph 5: One Step ahead Forecasts with 95% CI")
lines(dropFirst(a[, 2]), lty = "solid", col='red')
lines(dropFirst(a[, 2] + 1.96*sdR), lty = "dotdash", col='blue')
lines(dropFirst(a[, 2] - 1.96*sdR), lty = "dotdash", col='blue')
leg <- c("data", "One-step-Ahead Forecast","CI")
legend("bottomleft", legend = leg,
col = c("black", "red","blue"),
lty = c("solid", "solid", "dotdash"),
pch = c(16, NA, NA))
```


```{r Playing with signal to noise ratio}
mod1 <- dlmModPoly(order = 1, dV =100000 , dW =1300)
outFilt1 <- dlmFilter(Nile,mod1)
mod1$W/mod1$V

```
```{r Playing with signal to noise ratio again}
mod2 <- dlmModPoly(order = 1, dV =15000 , dW =5000000)
outFilt2 <- dlmFilter(Nile,mod2)
mod2$W/mod2$V
```

```{r signal to noise graph}
par(mar = c(2, 4, 1, 1) + 0.1, cex = 0.9)
plot(Nile,type="o", xlab = "", ylab = "Level",col='black', main = "Graph 6: Signal-to-noise")
lines(dropFirst(outFilt1$m), lty = "longdash", col='red')
lines(dropFirst(outFilt2$m), lty = "dotdash", col='blue')
leg <- c("data", paste("filtered, W/V =",
format(c(W(mod1) / V(mod1),
W(mod2) / V(mod2)))))
legend("bottomright", legend = leg,
col=c("black", "red", "blue"),
lty = c("solid", "longdash", "dotdash"),
pch = c(1, NA, NA), bty = "n")
```
We can see from the graph that when the increase W relative to V, the signal to noise ratio decreases and the uncertainty in the forecast increases. On the other hand, if V gets larger the signal gets larger relative to the noise and there is less uncertainty in the estimates
